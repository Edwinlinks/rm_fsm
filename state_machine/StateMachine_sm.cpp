//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : StateMachine.sm
//

#include "rm_fsm/StateMachine.h"
#include "../include/rm_fsm/common/data.h"
#include "../include/rm_fsm/common/fsm_common.h"
#include "/home/luotinkai/ros_ws/src/rm_software/rm_fsm/state_machine/StateMachine_sm.h"

using namespace statemap;

// Static class declarations.
StateMachineMap_Idle StateMachineMap::Idle("StateMachineMap::Idle", 0);
StateMachineMap_Raw StateMachineMap::Raw("StateMachineMap::Raw", 1);
StateMachineMap_Calibrate StateMachineMap::Calibrate("StateMachineMap::Calibrate", 2);
StateMachineMap_Standby StateMachineMap::Standby("StateMachineMap::Standby", 3);
StateMachineMap_Cruise StateMachineMap::Cruise("StateMachineMap::Cruise", 4);

void StateMachineState::checkCalibrateStatus(StateMachineContext& context)
{
    Default(context);
}

void StateMachineState::controlUpdate(StateMachineContext& context, rm_msgs::FsmCmd state)
{
    Default(context);
}

void StateMachineState::getCalibrateStatus(StateMachineContext& context)
{
    Default(context);
}

void StateMachineState::jumpCruise(StateMachineContext& context, rm_msgs::FsmCmd state)
{
    Default(context);
}

void StateMachineState::jumpStandby(StateMachineContext& context, rm_msgs::FsmCmd state)
{
    Default(context);
}

void StateMachineState::sendCommand(StateMachineContext& context)
{
    Default(context);
}

void StateMachineState::setChassis(StateMachineContext& context)
{
    Default(context);
}

void StateMachineState::setGimbal(StateMachineContext& context)
{
    Default(context);
}

void StateMachineState::setShooter(StateMachineContext& context)
{
    Default(context);
}

void StateMachineState::Default(StateMachineContext& context)
{
    throw (
        TransitionUndefinedException(
            (context.getState()).getName(),
            context.getTransition()));

}

void StateMachineMap_Idle::controlUpdate(StateMachineContext& context, rm_msgs::FsmCmd state)
{
    StateMachine& ctxt = context.getOwner();

    if ( ctxt.isCalibrate() == true )
    {
        context.getState().Exit(context);
        // No actions.
        context.setState(StateMachineMap::Calibrate);
        context.getState().Entry(context);
    }
    else if ( ctxt.isRaw() == true )

    {
        context.getState().Exit(context);
        // No actions.
        context.setState(StateMachineMap::Raw);
        context.getState().Entry(context);
    }    else
    {
         StateMachineMap_Default::controlUpdate(context, state);
    }


}

void StateMachineMap_Raw::Entry(StateMachineContext& context)

{
    StateMachine& ctxt = context.getOwner();

    ctxt.initRaw();
}

void StateMachineMap_Raw::controlUpdate(StateMachineContext& context, rm_msgs::FsmCmd state)
{
    StateMachine& ctxt = context.getOwner();

    if ( ctxt.isIdle() == true )
    {
        context.getState().Exit(context);
        // No actions.
        context.setState(StateMachineMap::Idle);
        context.getState().Entry(context);
    }
    else
    {
         StateMachineMap_Default::controlUpdate(context, state);
    }


}

void StateMachineMap_Raw::sendCommand(StateMachineContext& context)
{



}

void StateMachineMap_Raw::setChassis(StateMachineContext& context)
{



}

void StateMachineMap_Raw::setGimbal(StateMachineContext& context)
{



}

void StateMachineMap_Raw::setShooter(StateMachineContext& context)
{



}

void StateMachineMap_Calibrate::Entry(StateMachineContext& context)

{
    StateMachine& ctxt = context.getOwner();

    ctxt.initCalibrate();
}

void StateMachineMap_Calibrate::checkCalibrateStatus(StateMachineContext& context)
{



}

void StateMachineMap_Calibrate::controlUpdate(StateMachineContext& context, rm_msgs::FsmCmd state)
{
    StateMachine& ctxt = context.getOwner();

    if ( ctxt.isIdle() == true )
    {
        context.getState().Exit(context);
        // No actions.
        context.setState(StateMachineMap::Idle);
        context.getState().Entry(context);
    }
    else
    {
         StateMachineMap_Default::controlUpdate(context, state);
    }


}

void StateMachineMap_Calibrate::getCalibrateStatus(StateMachineContext& context)
{



}

void StateMachineMap_Calibrate::jumpCruise(StateMachineContext& context, rm_msgs::FsmCmd state)
{
    StateMachine& ctxt = context.getOwner();

    if ( ctxt.isCruise() == true )
    {
        context.getState().Exit(context);
        // No actions.
        context.setState(StateMachineMap::Cruise);
        context.getState().Entry(context);
    }
    else
    {
         StateMachineMap_Default::jumpCruise(context, state);
    }


}

void StateMachineMap_Calibrate::jumpStandby(StateMachineContext& context, rm_msgs::FsmCmd state)
{
    StateMachine& ctxt = context.getOwner();

    if ( ctxt.isStandby() == true )
    {
        context.getState().Exit(context);
        // No actions.
        context.setState(StateMachineMap::Standby);
        context.getState().Entry(context);
    }
    else
    {
         StateMachineMap_Default::jumpStandby(context, state);
    }


}

void StateMachineMap_Calibrate::sendCommand(StateMachineContext& context)
{



}

void StateMachineMap_Calibrate::setChassis(StateMachineContext& context)
{



}

void StateMachineMap_Calibrate::setGimbal(StateMachineContext& context)
{



}

void StateMachineMap_Calibrate::setShooter(StateMachineContext& context)
{



}

void StateMachineMap_Standby::Entry(StateMachineContext& context)

{
    StateMachine& ctxt = context.getOwner();

    ctxt.initStandby();
}

void StateMachineMap_Standby::controlUpdate(StateMachineContext& context, rm_msgs::FsmCmd state)
{
    StateMachine& ctxt = context.getOwner();

    if ( ctxt.isIdle() == true )
    {
        context.getState().Exit(context);
        // No actions.
        context.setState(StateMachineMap::Idle);
        context.getState().Entry(context);
    }
    else
    {
         StateMachineMap_Default::controlUpdate(context, state);
    }


}

void StateMachineMap_Standby::jumpCruise(StateMachineContext& context, rm_msgs::FsmCmd state)
{
    StateMachine& ctxt = context.getOwner();

    if ( ctxt.isCruise() == true )
    {
        context.getState().Exit(context);
        // No actions.
        context.setState(StateMachineMap::Cruise);
        context.getState().Entry(context);
    }
    else
    {
         StateMachineMap_Default::jumpCruise(context, state);
    }


}

void StateMachineMap_Standby::sendCommand(StateMachineContext& context)
{



}

void StateMachineMap_Standby::setChassis(StateMachineContext& context)
{



}

void StateMachineMap_Standby::setGimbal(StateMachineContext& context)
{



}

void StateMachineMap_Standby::setShooter(StateMachineContext& context)
{



}

void StateMachineMap_Cruise::Entry(StateMachineContext& context)

{
    StateMachine& ctxt = context.getOwner();

    ctxt.initCruise();
}

void StateMachineMap_Cruise::controlUpdate(StateMachineContext& context, rm_msgs::FsmCmd state)
{
    StateMachine& ctxt = context.getOwner();

    if ( ctxt.isIdle() == true )
    {
        context.getState().Exit(context);
        // No actions.
        context.setState(StateMachineMap::Idle);
        context.getState().Entry(context);
    }
    else
    {
         StateMachineMap_Default::controlUpdate(context, state);
    }


}

void StateMachineMap_Cruise::jumpStandby(StateMachineContext& context, rm_msgs::FsmCmd state)
{
    StateMachine& ctxt = context.getOwner();

    if ( ctxt.isStandby() == true )
    {
        context.getState().Exit(context);
        // No actions.
        context.setState(StateMachineMap::Standby);
        context.getState().Entry(context);
    }
    else
    {
         StateMachineMap_Default::jumpStandby(context, state);
    }


}

void StateMachineMap_Cruise::sendCommand(StateMachineContext& context)
{



}

void StateMachineMap_Cruise::setChassis(StateMachineContext& context)
{



}

void StateMachineMap_Cruise::setGimbal(StateMachineContext& context)
{



}

void StateMachineMap_Cruise::setShooter(StateMachineContext& context)
{



}

//
// Local variables:
//  buffer-read-only: t
// End:
//
